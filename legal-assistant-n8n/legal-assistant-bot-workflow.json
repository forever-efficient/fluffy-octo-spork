{
  "name": "Legal Assistant Bot",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "telegram-webhook",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "2e780617-3267-4aac-9fcc-5c6153b8f70e",
      "name": "Telegram Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -1840,
        464
      ],
      "webhookId": "880e4fb2-bdb9-4d42-af46-52c8a650584a"
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.body.message?.text || '' }}",
              "operation": "isNotEmpty"
            },
            {
              "value1": "={{ $json.body.message?.voice?.file_id || '' }}",
              "operation": "isNotEmpty"
            }
          ]
        },
        "combineOperation": "any"
      },
      "id": "c21c3214-37c8-4f56-870f-5d2e52daf35e",
      "name": "Has Message Content",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -1632,
        464
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.body.message?.voice ? 'voice' : 'text' }}",
              "value2": "voice"
            }
          ]
        }
      },
      "id": "606d503a-519f-40d4-97c5-4ceca60b4dbe",
      "name": "Is Voice Message",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -1408,
        352
      ]
    },
    {
      "parameters": {
        "resource": "file",
        "fileId": "={{ $json.body.message.voice.file_id }}",
        "additionalFields": {}
      },
      "id": "4ed96282-a9b9-43b1-a2bc-4f753dde53ed",
      "name": "Get Voice File",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        -1232,
        208
      ],
      "webhookId": "4320bc03-49dd-4e3e-bd34-328e9ba23d46",
      "credentials": {
        "telegramApi": {
          "id": "zcv8VyBLDeXHWW3a",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Fix file format for Groq API compatibility\nconst items = [];\n\nfor (const item of $input.all()) {\n  // Get the binary data from Telegram\n  const binaryData = item.binary?.data;\n  \n  if (binaryData) {\n    // Set proper filename and mime type for Groq API\n    binaryData.fileName = 'voice_message.ogg';\n    binaryData.mimeType = 'audio/ogg';\n    \n    items.push({\n      json: item.json,\n      binary: {\n        data: binaryData\n      }\n    });\n  } else {\n    items.push(item);\n  }\n}\n\nreturn items;"
      },
      "id": "49584cf7-dbf9-4ced-a800-4af7240e7d09",
      "name": "Fix Audio Format",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1040,
        160
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.groq.com/openai/v1/audio/transcriptions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer YOUR_GROQ_API_KEY_HERE"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            },
            {
              "name": "model",
              "value": "whisper-large-v3"
            },
            {
              "name": "response_format",
              "value": "json"
            }
          ]
        },
        "options": {}
      },
      "id": "654eca61-2e0a-44ed-867c-e2645df9171c",
      "name": "Transcribe Voice (Groq)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -864,
        208
      ]
    },
    {
      "parameters": {
        "jsCode": "// Extract and normalize message content\nconst items = [];\n\nfor (const item of $input.all()) {\n  let messageText = '';\n  let userId = '';\n  let chatId = '';\n  let messageId = '';\n  \n  // Handle different message types - check for body wrapper\n  const message = item.json.body?.message || item.json.message;\n  \n  if (message) {\n    userId = message.from.id;\n    chatId = message.chat.id;\n    messageId = message.message_id;\n    \n    // Text message\n    if (message.text) {\n      messageText = message.text;\n    }\n  }\n  \n  // Handle transcribed voice message from Groq API response\n  if (item.json.text && !messageText) {\n    messageText = item.json.text;\n    // Get user info from the original webhook data if available\n    const webhookData = $('Telegram Webhook').first()?.json;\n    if (webhookData?.body?.message) {\n      userId = webhookData.body.message.from.id;\n      chatId = webhookData.body.message.chat.id;\n      messageId = webhookData.body.message.message_id;\n    }\n  }\n  \n  items.push({\n    json: {\n      messageText: messageText,\n      userId: userId,\n      chatId: chatId,\n      messageId: messageId,\n      timestamp: new Date().toISOString(),\n      originalMessage: item.json\n    }\n  });\n}\n\nreturn items;"
      },
      "id": "8c5752a7-3582-4efe-b4e1-854d3f24391e",
      "name": "Normalize Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1184,
        464
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.groq.com/openai/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer YOUR_GROQ_API_KEY_HERE"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"llama-3.3-70b-versatile\",\n  \"messages\": [{\n      \"role\": \"system\",\n      \"content\": \"You are a content classifier for a legal assistant bot. Determine if messages are related to legal/criminal matters.\\n\\nRespond with 'VALID' if the message contains:\\n- Direct legal questions\\n- Criminal scenarios or situations\\n- Descriptions of potential crimes or violations\\n- Court cases, statutes, or legal procedures\\n- Requests for legal advice or analysis\\n- Fact patterns that may involve legal issues\\n- Property damage or destruction scenarios\\n- Domestic disputes or relationship conflicts with legal implications\\n- Theft, assault, harassment, or any criminal behavior\\n- Civil law matters (contracts, torts, property disputes)\\n\\nRespond with 'INVALID: [brief reason]' if the message is clearly unrelated to legal matters (weather, sports, general chat, etc.).\\n\\nExamples of VALID messages:\\n- 'What are Miranda rights?'\\n- 'A wife smashes her husband's phone'\\n- 'Someone took my bike without permission'\\n- 'What happens if I don't pay a traffic ticket?'\\n- 'My neighbor is playing loud music at 2am'\\n- 'Wife smashed my phone'\\n- 'My landlord won't fix the heat'\\n- 'Someone hit my car and drove away'\"\n  }, {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.messageText }}\"\n  }]\n} ",
        "options": {}
      },
      "id": "1dfb27fc-0b55-416b-bc38-efdc6942a842",
      "name": "Validate Content (Groq)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -960,
        464
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.choices[0].message.content }}",
              "value2": "VALID"
            }
          ]
        }
      },
      "id": "dbc09ecd-bc22-4241-bbd8-552750389530",
      "name": "Is Valid Request",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -736,
        464
      ]
    },
    {
      "parameters": {
        "tableId": "user_conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Normalize Message').item.json.userId + Math.floor(Math.random() * 1000) + 1}}"
            },
            {
              "fieldId": "chat_id",
              "fieldValue": "={{ $('Normalize Message').item.json.chatId + Math.floor(Math.random() * 1000) + 1}}"
            },
            {
              "fieldId": "conversation_history",
              "fieldValue": "={{ $('Normalize Message').item.json.messageText }}"
            }
          ]
        }
      },
      "id": "060f1e1c-e3b1-42d3-98ea-874360c58fab",
      "name": "Log Rejection",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        512,
        960
      ],
      "credentials": {
        "supabaseApi": {
          "id": "GAXI2okVDAx3Ea8z",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $('Normalize Message').item.json.chatId }}",
        "text": "=I'm sorry, but I can only assist with legal and criminal matters. Your message appears to be outside my scope of expertise.\n\nReason: {{ $('Validate Content (Groq)').item.json.choices[0].message.content }}\n\nI can help you with:\nâ€¢ Direct legal questions (\"What are Miranda rights?\")\nâ€¢ Criminal scenarios (\"Someone took my bike without asking\")\nâ€¢ Court cases and rulings\nâ€¢ Legal procedures and statutes\nâ€¢ Fact patterns involving potential crimes\nâ€¢ Civil and criminal law analysis",
        "additionalFields": {}
      },
      "id": "5047b64d-d6bc-481a-986d-9b1e294de151",
      "name": "Send Rejection Response",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        768,
        960
      ],
      "webhookId": "69b01ef0-fb89-4362-8090-8a666c12a2bc",
      "credentials": {
        "telegramApi": {
          "id": "zcv8VyBLDeXHWW3a",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "tableId": "user_conversations",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "keyValue": "={{ $('Normalize Message').item.json.userId }}"
            }
          ]
        }
      },
      "id": "37ebd4e7-4e90-4184-9b41-074d7e71079a",
      "name": "Get Conversation Memory",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        480,
        448
      ],
      "credentials": {
        "supabaseApi": {
          "id": "GAXI2okVDAx3Ea8z",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare AI Context - Process all inputs and create comprehensive AI prompt\nconsole.log('=== PREPARE AI CONTEXT PROCESSING ===');\nconsole.log('Input items count:', $input.all().length);\n\n// Extract user data from Normalize Message node\nlet userQuery = $('Normalize Message').item.json.messageText || '';\nlet userId = $('Normalize Message').item.json.userId || null;\nlet chatId = $('Normalize Message').item.json.chatId || null;\nlet messageId = $('Normalize Message').item.json.messageId || null;\n\n// Extract conversation history from Get Conversation Memory node\nlet conversationHistory = '';\nfor (const item of $input.all()) {\n  if (item.json.conversation_history) {\n    conversationHistory = item.json.conversation_history;\n    console.log('Found conversation history:', conversationHistory.substring(0, 100));\n    break;\n  }\n}\n\n// Extract legal documents from Get Legal Documents node\nlet legalDocs = '';\nfor (const item of $input.all()) {\n  if (item.json.title && item.json.content) {\n    legalDocs += `[${item.json.type || 'Document'}] ${item.json.title}: ${item.json.content.substring(0, 500)}...\\n\\n`;\n  }\n}\n\n// Extract vector search results\nlet vectorResults = '';\nfor (const item of $input.all()) {\n  if (item.json.similarity && item.json.content) {\n    vectorResults += `[Vector Match ${item.json.similarity}] ${item.json.title || 'Document'}: ${item.json.content.substring(0, 300)}...\\n\\n`;\n  }\n}\n\n// *** NEW: Extract Court Listener case law results ***\nlet courtListenerResults = '';\nfor (const item of $input.all()) {\n  if (item.json.results && Array.isArray(item.json.results)) {\n    console.log('Found Justia results:', item.json.results.length);\n    for (const caseResult of item.json.results.slice(0, 5)) {\n      if (caseResult.caseName) {\n        const citation = Array.isArray(caseResult.citation) ? caseResult.citation.join(', ') : (caseResult.citation || 'No citation');\n        const cleanSnippet = (caseResult.opinions && caseResult.opinions[0] && caseResult.opinions[0].snippet) ? caseResult.opinions[0].snippet.replace(/<mark>/g, '**').replace(/<\\/mark>/g, '**') : (caseResult.snippet || 'No summary available').replace(/<mark>/g, '**').replace(/<\\/mark>/g, '**');\n        courtListenerResults += `[Supreme Court Case] ${caseResult.caseName} (${citation}): ${cleanSnippet.substring(0, 400)}...\\n\\n`;\n      }\n    }\n    break; // Only process first Court Listener result set\n  }\n}\n\n// Extract web search results from API nodes\nlet webSearchResults = '';\nfor (const item of $input.all()) {\n  if (item.json.statusCode === 200 && item.json.body) {\n    const searchSource = item.json.url ? new URL(item.json.url).hostname : 'Web Search';\n    webSearchResults += `[${searchSource}] Search results available\\n`;\n  }\n}\n\n// Enhanced semantic reasoning AI prompt\nconst aiPrompt = `You are a legal research assistant. Analyze the user scenario and provide relevant legal authorities in the exact structured format below.\n\nUSER SCENARIO: \"${userQuery}\"\n\n${vectorResults ? `RELEVANT LEGAL DOCUMENTS FROM RAG SEARCH:\\n${vectorResults}` : ''}\n${courtListenerResults ? `RELEVANT CASE LAW FROM SUPREME COURT:\\n${courtListenerResults}` : ''}\n${legalDocs ? `AVAILABLE LEGAL AUTHORITIES:\\n${legalDocs}` : ''}\n\nANALYSIS INSTRUCTIONS:\n1. Analyze the user scenario to identify potential legal issues (e.g., \"wife smashes phone\" = property destruction + domestic violence)\n2. Extract the EXACT statute numbers and titles from the vector search results and match them to the user scenario\n3. CRITICAL: Format ALL Colorado statutes with \"C.R.S.\" prefix. Look for patterns like \"18-4-205\", \"section 18-4-602\", etc. and format them as \"C.R.S. 18-4-205\" with descriptive titles from the document content.\n4. Extract statute descriptions/titles from the legal text (e.g., \"Theft\", \"Criminal Mischief\", \"Assault\") that appear near the statute numbers\n5. Include relevant Supreme Court case law and federal precedents from the case law results above.\n6. Use this EXACT format for your response:\n\nRELEVANT LEGAL AUTHORITIES:\n\nðŸ“‹ CASE LAW:\nâ€¢ [Case Name] = [How it applies to this specific scenario]\n\nðŸ“œ STATUTES/LAWS:\nâ€¢ C.R.S. [NUMBER] ([STATUTE TITLE/DESCRIPTION]) = [How it applies to this specific scenario]\n\nâš–ï¸ CHARGES/PENALTIES:\nâ€¢ [Charge Name] = [Likelihood and severity for this scenario]\nâ€¢ [Penalty] = [Potential consequences for this scenario]\n\n7. STATUTE FORMAT EXAMPLES:\n   - Format: \"C.R.S. 18-4-401 (Theft)\" NOT just \"18-4-401\"\n   - Format: \"C.R.S. 18-4-501 (Criminal Mischief)\" NOT just \"18-4-501\"\n   - Include the descriptive name in parentheses when available in the text\n8. Only include items that are DIRECTLY relevant to the user's scenario\n9. Do NOT write paragraphs - use the bullet point format\n10. Connect the legal authorities to the specific facts in the scenario\n11. If the scenario involves multiple legal issues, address each one\n12. Include additional bullet points for additional findings.\n\nIf no relevant legal authorities are found in the provided documents, respond with:\nâŒ NO RELEVANT LEGAL AUTHORITIES FOUND - The scenario may involve legal issues not covered in the current database.\n\nFocus on making connections between the user's scenario and the legal principles, not just listing generic laws.`;\n\n// Single output object with all processed data\nconst result = {\n  aiPrompt: aiPrompt,\n  userMessage: userQuery,\n  userId: userId,\n  chatId: chatId,\n  messageId: messageId,\n  conversationHistory: conversationHistory,\n  timestamp: new Date().toISOString()\n};\n\nconsole.log('=== RETURNING SINGLE ITEM ===');\nconsole.log('User query:', userQuery);\nconsole.log('Legal docs length:', legalDocs.length);\nconsole.log('Vector results length:', vectorResults.length);\nconsole.log('Justia results length:', courtListenerResults.length);\n\n// Return exactly ONE item\nreturn { json: result };"
      },
      "id": "05a36545-4ef9-4539-838a-2689636d4ef2",
      "name": "Prepare AI Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1440,
        80
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.groq.com/openai/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer YOUR_GROQ_API_KEY_HERE"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"llama-3.3-70b-versatile\",\n  \"messages\": [{\n      \"role\": \"system\",\n      \"content\": \"You are a specialized legal AI assistant with expertise in criminal law and legal matters. Provide comprehensive, accurate legal analysis based on the provided context.\"\n  }, {\n      \"role\": \"user\",\n      \"content\": {{ JSON.stringify($json.aiPrompt) }}\n  }],\n  \"max_tokens\": 2000,\n  \"temperature\": 0.3\n}",
        "options": {}
      },
      "id": "498609b0-13d9-4809-8274-62edecbfef94",
      "name": "AI Legal Analysis (Groq)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1664,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "// Format AI response with HTML line breaks for Telegram\n// FIXED: Only process the first item to prevent duplicates\nconst items = [];\n\n// Get AI response from Groq format - ONLY process first item\nconst firstInput = $input.first();\nif (!firstInput) {\n  return [];\n}\n\nconst aiResponse = firstInput.json.choices && firstInput.json.choices[0] && firstInput.json.choices[0].message && firstInput.json.choices[0].message.content || 'Unable to generate response';\n\n// Get the context data from Prepare AI Context node - THIS IS THE FIX!\nconst context = $('Prepare AI Context').first().json;\n\n// Update conversation history\nconst newConversationEntry = `User: ${context.userMessage || 'Unknown query'}\\nAssistant: ${aiResponse}\\n---\\n`;\nconst updatedHistory = (context.conversationHistory || '') + newConversationEntry;\n\n// Clean formatting and convert to HTML for Telegram\nlet formattedResponse = aiResponse;\n\n// Telegram message limit is 4096 characters\nconst MAX_LENGTH = 4000; // Leave some buffer\n\nif (formattedResponse.length > MAX_LENGTH) {\n  // Try to find a good break point\n  let truncateAt = MAX_LENGTH;\n  const breakPoints = ['. ', '\\n', ': '];\n  \n  for (const breakPoint of breakPoints) {\n    const lastBreak = formattedResponse.lastIndexOf(breakPoint, MAX_LENGTH - 100);\n    if (lastBreak > MAX_LENGTH / 2) {\n      truncateAt = lastBreak + breakPoint.length;\n      break;\n    }\n  }\n  \n  formattedResponse = formattedResponse.substring(0, truncateAt);\n}\n\nconsole.log('Format Response: Processing single item to prevent duplicates');\n\n// Return only ONE item\nitems.push({\n  json: {\n    formattedResponse: formattedResponse,\n    // USE PRESERVED USER DATA - This is the fix!\n    userId: context.userId,\n    chatId: context.chatId,\n    messageId: context.messageId,\n    updatedConversationHistory: updatedHistory,\n    timestamp: context.timestamp,\n    rawAiResponse: aiResponse\n  }\n});\n\nreturn items;"
      },
      "id": "447a72e5-53bb-453c-99c6-71ddb5e77b74",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1872,
        80
      ]
    },
    {
      "parameters": {
        "tableId": "user_conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Normalize Message').last().json.userId }}"
            },
            {
              "fieldId": "chat_id",
              "fieldValue": "={{ $('Normalize Message').last().json.messageId + Math.floor(Math.random() * 100000) + 1}}"
            }
          ]
        }
      },
      "id": "2ed86f62-a474-4ce7-82a6-dcc6f8feb835",
      "name": "Update Conversation Memory",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2112,
        80
      ],
      "credentials": {
        "supabaseApi": {
          "id": "GAXI2okVDAx3Ea8z",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $('Format Response').item.json.userId }}",
        "text": "={{ $('Format Response').item.json.formattedResponse }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "id": "5a5d2e58-1047-462d-ad6a-981e5faa65e3",
      "name": "Send Legal Response",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        2400,
        80
      ],
      "webhookId": "0c42ae07-bca7-4767-8279-c91b56cab3dd",
      "credentials": {
        "telegramApi": {
          "id": "zcv8VyBLDeXHWW3a",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"status\": \"success\", \"message\": \"Message processed successfully\" } }}",
        "options": {}
      },
      "id": "47d6ee0b-1de6-43dc-9986-f69edcfb1117",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        2640,
        528
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api-inference.huggingface.co/models/BAAI/bge-small-en-v1.5",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBearerAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"inputs\": {{ JSON.stringify($('Normalize Message').item.json.messageText) }}\n}",
        "options": {}
      },
      "id": "generate-embedding-node",
      "name": "Generate Query Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        272,
        256
      ],
      "credentials": {
        "httpBearerAuth": {
          "id": "PjauxqUSAtZQPsh1",
          "name": "Bearer Auth account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "=https://caselaw.findlaw.com/search.html?query={{ encodeURIComponent($('Legal Term Interpreter (Groq)').item.json.choices[0].message.content) }}",
        "options": {}
      },
      "id": "search-findlaw-node",
      "name": "Search FindLaw Database",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        432,
        48
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "=https://www.law.cornell.edu/search/site?query={{ encodeURIComponent($('Legal Term Interpreter (Groq)').item.json.choices[0].message.content) }}",
        "options": {}
      },
      "id": "search-cornell-node",
      "name": "Search Cornell Law",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        432,
        -128
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "=https://scholar.google.com/scholar?q={{ encodeURIComponent($('Legal Term Interpreter (Groq)').item.json.choices[0].message.content) }}+law+case&hl=en&as_sdt=6",
        "options": {}
      },
      "id": "search-scholar-node",
      "name": "Search Google Scholar Legal",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        432,
        -304
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://ioncpiocmpusocereeia.supabase.co/rest/v1/rpc/match_legal_documents",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBearerAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "apikey",
              "value": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlvbmNwaW9jbXB1c29jZXJlZWlhIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2MDA5Mzc2NiwiZXhwIjoyMDc1NjY5NzY2fQ.eLkYThE01N7JDbNGx1x9B2ja17jNE-dPj7Qxj_NLvtY"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"query_embedding\": {{ JSON.stringify($('Debug Embedding Response').item.json.embedding) }},\n  \"match_threshold\": 0.3,\n  \"match_count\": 5\n}",
        "options": {}
      },
      "id": "vector-search-http-request",
      "name": "Vector Search HTTP Request",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        672,
        256
      ],
      "alwaysOutputData": true,
      "credentials": {
        "httpHeaderAuth": {
          "id": "PjauxqUSAtZQPsh1",
          "name": "Bearer Auth account"
        },
        "httpBearerAuth": {
          "id": "a16BZtr8olObDWKP",
          "name": "Bearer Auth account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Debug and fix the embedding response format\nconst items = [];\n\n// The HuggingFace API returns individual numbers, but we need them as an array\nconst embeddingArray = [];\nfor (const item of $input.all()) {\n  if (typeof item.json === 'number') {\n    embeddingArray.push(item.json);\n  }\n}\n\nconsole.log(\"Embedding array length:\", embeddingArray.length);\nconsole.log(\"First few elements:\", embeddingArray.slice(0, 5));\nconsole.log(\"Embedding array type:\", typeof embeddingArray);\nconsole.log(\"Is array:\", Array.isArray(embeddingArray));\n\n// Return the properly formatted embedding as a single item\n// n8n requires json to be an object, so wrap the array in an object\nitems.push({\n  json: {\n    embedding: embeddingArray,\n    length: embeddingArray.length,\n    sample: embeddingArray.slice(0, 3)\n  }\n});\n\nreturn items;"
      },
      "id": "debug-embedding-response",
      "name": "Debug Embedding Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        256
      ]
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "legal_documents",
        "matchType": "allFilters"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        480,
        656
      ],
      "id": "1ecd0351-df3b-461d-9bc6-332a6598608c",
      "name": "Get Legal Documents",
      "credentials": {
        "supabaseApi": {
          "id": "GAXI2okVDAx3Ea8z",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "numberInputs": 7
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1072,
        288
      ],
      "id": "4f000040-ec3d-4834-8950-9e086ce7f5b4",
      "name": "Merge"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.groq.com/openai/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer YOUR_GROQ_API_KEY_HERE"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"llama-3.3-70b-versatile\",\n  \"messages\": [{\n      \"role\": \"system\",\n      \"content\": \"You are a legal terminology expert. Convert user descriptions into proper legal search terms for case law databases.\\n\\nYour task: Transform colloquial descriptions into precise legal concepts that would appear in court cases and legal databases.\\n\\nGuidelines:\\n- Focus on the underlying legal violations and charges\\n- Use standard legal terminology that would appear in case law\\n- Include related criminal and civil concepts\\n- Format as search terms separated by OR\\n- Be comprehensive but precise\\n\\nExamples:\\n- 'smashed phone' â†’ 'property damage OR criminal mischief OR destruction of property OR vandalism'\\n- 'wife/husband' â†’ 'domestic violence OR intimate partner violence OR domestic relations OR marital discord'\\n- 'hit someone' â†’ 'assault OR battery OR domestic violence OR physical abuse'\\n- 'took without asking' â†’ 'theft OR larceny OR conversion OR stolen property'\\n- 'broke into house' â†’ 'burglary OR breaking and entering OR trespass OR unlawful entry'\\n\\nRespond with ONLY the legal search terms, no explanation.\"\n  }, {\n      \"role\": \"user\",\n      \"content\": \"{{ $('Normalize Message').item.json.messageText }}\"\n  }],\n  \"max_tokens\": 150,\n  \"temperature\": 0.1\n}",
        "options": {}
      },
      "id": "legal-term-interpreter",
      "name": "Legal Term Interpreter (Groq)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -128,
        32
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse Google Scholar HTML to extract case information\nconst items = [];\n\nfor (const item of $input.all()) {\n  let cases = [];\n  \n  if (item.json.data && typeof item.json.data === 'string') {\n    const html = item.json.data;\n    \n    try {\n      // Extract case results using regex patterns\n      // Google Scholar case results are in div.gs_r elements\n      const caseMatches = html.match(/<div class=\"gs_r[^\"]*\">.*?<\\/div>(?=\\s*<div class=\"gs_r|\\s*<\\/div>)/gs) || [];\n      \n      console.log(`Found ${caseMatches.length} potential case matches`);\n      \n      for (let i = 0; i < Math.min(caseMatches.length, 10); i++) {\n        const caseHtml = caseMatches[i];\n        \n        // Extract case title/name from <h3 class=\"gs_rt\">\n        const titleMatch = caseHtml.match(/<h3[^>]*class=\"[^\"]*gs_rt[^\"]*\"[^>]*>.*?<a[^>]*>([^<]+)<\\/a>.*?<\\/h3>/s);\n        const caseName = titleMatch ? titleMatch[1].trim() : null;\n        \n        // Extract citation from <div class=\"gs_a\">\n        const citationMatch = caseHtml.match(/<div[^>]*class=\"[^\"]*gs_a[^\"]*\"[^>]*>([^<]+)</s);\n        let citation = citationMatch ? citationMatch[1].trim() : '';\n        \n        // Clean up citation (remove HTML entities, extra spaces)\n        citation = citation.replace(/&[^;]+;/g, ' ').replace(/\\s+/g, ' ').trim();\n        \n        // Extract snippet from <div class=\"gs_rs\">\n        const snippetMatch = caseHtml.match(/<div[^>]*class=\"[^\"]*gs_rs[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/s);\n        let snippet = snippetMatch ? snippetMatch[1] : '';\n        \n        // Clean snippet - remove HTML tags, decode entities, clean whitespace\n        snippet = snippet\n          .replace(/<[^>]+>/g, ' ')  // Remove HTML tags\n          .replace(/&[^;]+;/g, ' ')  // Remove HTML entities\n          .replace(/\\s+/g, ' ')      // Normalize whitespace\n          .trim();\n        \n        // Extract case URL if available\n        const urlMatch = caseHtml.match(/<a[^>]+href=\"([^\"]+)\"[^>]*>[^<]+<\\/a>/);\n        const caseUrl = urlMatch ? urlMatch[1] : null;\n        \n        // Only include if we have meaningful data\n        if (caseName && (citation || snippet)) {\n          cases.push({\n            caseName: caseName,\n            citation: citation || 'Citation not available',\n            snippet: snippet.substring(0, 300) + (snippet.length > 300 ? '...' : ''),\n            url: caseUrl,\n            source: 'Google Scholar',\n            relevanceScore: Math.max(0.9 - (i * 0.1), 0.1) // Decrease relevance by position\n          });\n        }\n      }\n      \n      console.log(`Successfully parsed ${cases.length} cases from Google Scholar`);\n      \n    } catch (error) {\n      console.error('Error parsing Google Scholar HTML:', error);\n      \n      // Fallback: try to extract any text that looks like case names\n      const fallbackMatches = html.match(/([A-Z][a-z]+ v\\. [A-Z][a-z]+|[A-Z][a-z]+ v [A-Z][a-z]+)/g) || [];\n      for (let i = 0; i < Math.min(fallbackMatches.length, 5); i++) {\n        cases.push({\n          caseName: fallbackMatches[i],\n          citation: 'Citation extraction failed',\n          snippet: 'Content extraction failed - raw HTML parsing error',\n          url: null,\n          source: 'Google Scholar (fallback)',\n          relevanceScore: 0.5\n        });\n      }\n    }\n  }\n  \n  // Return structured case data\n  items.push({\n    json: {\n      source: 'google_scholar',\n      cases: cases,\n      totalFound: cases.length,\n      searchQuery: item.json.searchQuery || 'Unknown',\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\nreturn items;"
      },
      "id": "parse-scholar-html",
      "name": "Parse Google Scholar HTML",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        -304
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse Cornell Law HTML to extract legal content\nconst items = [];\n\nfor (const item of $input.all()) {\n  let legalContent = [];\n  \n  if (item.json.data && typeof item.json.data === 'string') {\n    const html = item.json.data;\n    \n    try {\n      console.log('Parsing Cornell Law HTML...');\n      \n      // Cornell Law uses different structures for different content types\n      // Method 1: Extract search result items (common pattern)\n      const resultMatches = html.match(/<div[^>]*class=\"[^\"]*search-result[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi) || [];\n      \n      console.log(`Found ${resultMatches.length} search result items`);\n      \n      for (let i = 0; i < Math.min(resultMatches.length, 8); i++) {\n        const resultHtml = resultMatches[i];\n        \n        // Extract title/heading\n        const titleMatch = resultHtml.match(/<h[1-6][^>]*>.*?<a[^>]*>([^<]+)<\\/a>.*?<\\/h[1-6]>/i) || \n                          resultHtml.match(/<a[^>]*class=\"[^\"]*title[^\"]*\"[^>]*>([^<]+)<\\/a>/i);\n        const title = titleMatch ? titleMatch[1].trim() : null;\n        \n        // Extract URL\n        const urlMatch = resultHtml.match(/<a[^>]+href=\"([^\"]+)\"[^>]*>/i);\n        let url = urlMatch ? urlMatch[1] : null;\n        if (url && !url.startsWith('http')) {\n          url = url.startsWith('/') ? 'https://www.law.cornell.edu' + url : 'https://www.law.cornell.edu/' + url;\n        }\n        \n        // Extract description/snippet\n        const descMatch = resultHtml.match(/<p[^>]*class=\"[^\"]*description[^\"]*\"[^>]*>([^<]+)<\\/p>/i) ||\n                         resultHtml.match(/<div[^>]*class=\"[^\"]*snippet[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i);\n        let description = descMatch ? descMatch[1].trim() : '';\n        \n        // Clean description\n        description = description\n          .replace(/<[^>]+>/g, ' ')\n          .replace(/&[^;]+;/g, ' ')\n          .replace(/\\s+/g, ' ')\n          .trim();\n        \n        if (title && (description || url)) {\n          legalContent.push({\n            title: title,\n            description: description.substring(0, 200) + (description.length > 200 ? '...' : ''),\n            url: url,\n            source: 'Cornell Law School',\n            type: 'legal_article',\n            relevanceScore: Math.max(0.8 - (i * 0.1), 0.2)\n          });\n        }\n      }\n      \n      // Method 2: Extract statute references and legal definitions\n      const statuteMatches = html.match(/\\b\\d+\\s+U\\.?S\\.?C\\.?\\s*Â§?\\s*\\d+[a-z]*(?:\\([^)]+\\))?/gi) || [];\n      const cfr_matches = html.match(/\\b\\d+\\s+C\\.?F\\.?R\\.?\\s*Â§?\\s*\\d+(?:\\.\\d+)*/gi) || [];\n      \n      if (statuteMatches.length > 0 || cfr_matches.length > 0) {\n        const allStatutes = [...new Set([...statuteMatches, ...cfr_matches])];\n        for (let j = 0; j < Math.min(allStatutes.length, 5); j++) {\n          legalContent.push({\n            title: `Federal Statute: ${allStatutes[j]}`,\n            description: `Legal reference found in Cornell Law database`,\n            url: null,\n            source: 'Cornell Law School',\n            type: 'statute_reference',\n            relevanceScore: 0.7\n          });\n        }\n      }\n      \n      // Method 3: Fallback - extract any content that looks legal\n      if (legalContent.length === 0) {\n        const fallbackMatches = html.match(/([A-Z][a-z]+\\s+v\\.?\\s+[A-Z][a-z]+|\\d+\\s+U\\.S\\.|Â§\\s*\\d+)/gi) || [];\n        for (let k = 0; k < Math.min(fallbackMatches.length, 3); k++) {\n          legalContent.push({\n            title: fallbackMatches[k],\n            description: 'Legal reference extracted from Cornell Law',\n            url: null,\n            source: 'Cornell Law School (extracted)',\n            type: 'legal_reference',\n            relevanceScore: 0.5\n          });\n        }\n      }\n      \n      console.log(`Successfully parsed ${legalContent.length} items from Cornell Law`);\n      \n    } catch (error) {\n      console.error('Error parsing Cornell Law HTML:', error);\n      \n      // Basic fallback\n      legalContent.push({\n        title: 'Cornell Law Search Results',\n        description: 'Content parsing failed - search results available but not parsed',\n        url: null,\n        source: 'Cornell Law School',\n        type: 'search_results',\n        relevanceScore: 0.3\n      });\n    }\n  }\n  \n  // Return structured legal content\n  items.push({\n    json: {\n      source: 'cornell_law',\n      content: legalContent,\n      totalFound: legalContent.length,\n      searchQuery: item.json.searchQuery || 'Unknown',\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\nreturn items;"
      },
      "id": "parse-cornell-html",
      "name": "Parse Cornell Law HTML",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        -128
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse FindLaw HTML to extract case law and legal content\nconst items = [];\n\nfor (const item of $input.all()) {\n  let legalContent = [];\n  \n  if (item.json.data && typeof item.json.data === 'string') {\n    const html = item.json.data;\n    \n    try {\n      console.log('Parsing FindLaw HTML...');\n      \n      // FindLaw typically uses specific patterns for case results\n      // Method 1: Extract case law results from search\n      const caseMatches = html.match(/<div[^>]*class=\"[^\"]*result[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi) || \n                         html.match(/<article[^>]*class=\"[^\"]*case[^\"]*\"[^>]*>[\\s\\S]*?<\\/article>/gi) || [];\n      \n      console.log(`Found ${caseMatches.length} case result items`);\n      \n      for (let i = 0; i < Math.min(caseMatches.length, 8); i++) {\n        const caseHtml = caseMatches[i];\n        \n        // Extract case title/name\n        const titleMatch = caseHtml.match(/<h[1-6][^>]*>.*?<a[^>]*>([^<]+)<\\/a>.*?<\\/h[1-6]>/i) ||\n                          caseHtml.match(/<a[^>]*class=\"[^\"]*title[^\"]*\"[^>]*>([^<]+)<\\/a>/i) ||\n                          caseHtml.match(/<a[^>]*>([A-Z][a-z]+\\s+v\\.?\\s+[A-Z][a-z]+[^<]*)<\\/a>/i);\n        const title = titleMatch ? titleMatch[1].trim() : null;\n        \n        // Extract case URL\n        const urlMatch = caseHtml.match(/<a[^>]+href=\"([^\"]+)\"[^>]*>/i);\n        let url = urlMatch ? urlMatch[1] : null;\n        if (url && !url.startsWith('http')) {\n          url = url.startsWith('/') ? 'https://caselaw.findlaw.com' + url : 'https://caselaw.findlaw.com/' + url;\n        }\n        \n        // Extract court and date information\n        const courtMatch = caseHtml.match(/([A-Z][a-z\\s]+Court[^,]*)/i);\n        const court = courtMatch ? courtMatch[1].trim() : null;\n        \n        const dateMatch = caseHtml.match(/(\\d{4}|\\w+\\s+\\d{1,2},\\s+\\d{4})/i);\n        const date = dateMatch ? dateMatch[1] : null;\n        \n        // Extract description/snippet\n        const descMatch = caseHtml.match(/<p[^>]*class=\"[^\"]*description[^\"]*\"[^>]*>([\\s\\S]*?)<\\/p>/i) ||\n                         caseHtml.match(/<div[^>]*class=\"[^\"]*snippet[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i) ||\n                         caseHtml.match(/<p[^>]*>([\\s\\S]{50,300}?)<\\/p>/i);\n        let description = descMatch ? descMatch[1].trim() : '';\n        \n        // Clean description\n        description = description\n          .replace(/<[^>]+>/g, ' ')\n          .replace(/&[^;]+;/g, ' ')\n          .replace(/\\s+/g, ' ')\n          .trim();\n        \n        if (title && (description || court || date)) {\n          legalContent.push({\n            title: title,\n            description: description.substring(0, 250) + (description.length > 250 ? '...' : ''),\n            court: court,\n            date: date,\n            url: url,\n            source: 'FindLaw',\n            type: 'case_law',\n            relevanceScore: Math.max(0.9 - (i * 0.1), 0.2)\n          });\n        }\n      }\n      \n      // Method 2: Extract statute and code references\n      const statuteMatches = html.match(/\\b\\d+\\s+U\\.?S\\.?C\\.?\\s*Â§?\\s*\\d+[a-z]*(?:\\([^)]+\\))?/gi) || [];\n      const stateCodeMatches = html.match(/\\b[A-Z]{2,}\\s+Â§?\\s*\\d+[a-z]*(?:[.-]\\d+)*/gi) || [];\n      \n      if (statuteMatches.length > 0 || stateCodeMatches.length > 0) {\n        const allStatutes = [...new Set([...statuteMatches, ...stateCodeMatches])];\n        for (let j = 0; j < Math.min(allStatutes.length, 4); j++) {\n          legalContent.push({\n            title: `Legal Code: ${allStatutes[j]}`,\n            description: `Statute reference found in FindLaw database`,\n            court: null,\n            date: null,\n            url: null,\n            source: 'FindLaw',\n            type: 'statute_reference',\n            relevanceScore: 0.7\n          });\n        }\n      }\n      \n      // Method 3: Extract legal definitions and concepts\n      const definitionMatches = html.match(/\"[^\"]{20,100}\"/g) || [];\n      for (let k = 0; k < Math.min(definitionMatches.length, 3); k++) {\n        const definition = definitionMatches[k].replace(/\"/g, '').trim();\n        if (definition.length > 30) {\n          legalContent.push({\n            title: 'Legal Definition',\n            description: definition,\n            court: null,\n            date: null,\n            url: null,\n            source: 'FindLaw',\n            type: 'definition',\n            relevanceScore: 0.6\n          });\n        }\n      }\n      \n      // Method 4: Fallback - extract any case-like patterns\n      if (legalContent.length === 0) {\n        const fallbackMatches = html.match(/([A-Z][a-z]+\\s+v\\.?\\s+[A-Z][a-z]+|[A-Z][A-Z\\s]+Court)/gi) || [];\n        for (let l = 0; l < Math.min(fallbackMatches.length, 3); l++) {\n          legalContent.push({\n            title: fallbackMatches[l],\n            description: 'Legal reference extracted from FindLaw',\n            court: null,\n            date: null,\n            url: null,\n            source: 'FindLaw (extracted)',\n            type: 'legal_reference',\n            relevanceScore: 0.4\n          });\n        }\n      }\n      \n      console.log(`Successfully parsed ${legalContent.length} items from FindLaw`);\n      \n    } catch (error) {\n      console.error('Error parsing FindLaw HTML:', error);\n      \n      // Basic fallback\n      legalContent.push({\n        title: 'FindLaw Search Results',\n        description: 'Content parsing failed - search results available but not parsed',\n        court: null,\n        date: null,\n        url: null,\n        source: 'FindLaw',\n        type: 'search_results',\n        relevanceScore: 0.3\n      });\n    }\n  }\n  \n  // Return structured legal content\n  items.push({\n    json: {\n      source: 'findlaw',\n      content: legalContent,\n      totalFound: legalContent.length,\n      searchQuery: item.json.searchQuery || 'Unknown',\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\nreturn items;"
      },
      "id": "parse-findlaw-html",
      "name": "Parse FindLaw HTML",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        48
      ]
    },
    {
      "parameters": {
        "url": "=https://www.courtlistener.com/api/rest/v4/search/?type=o&court=scotus&q={{ encodeURIComponent($('Legal Term Interpreter (Groq)').item.json.choices[0].message.content) }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Token {{$env.COURTLISTENER_API_TOKEN}}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        592,
        -480
      ],
      "id": "4d9017a9-8b77-4c55-9e05-a7c0b7e814f7",
      "name": "Search CourtListener Database",
      "alwaysOutputData": true,
      "credentials": {
        "httpBearerAuth": {
          "id": "a16BZtr8olObDWKP",
          "name": "Bearer Auth account 2"
        },
        "httpHeaderAuth": {
          "id": "HttOqB55b67CXus3",
          "name": "Header Auth account"
        },
        "httpBasicAuth": {
          "id": "ONIcJliF0pjYFaoI",
          "name": "Unnamed credential"
        }
      }
    }
  ],
  "pinData": {
    "Telegram Webhook": [
      {
        "json": {
          "headers": {
            "host": "n8n.modernwizard.win",
            "content-length": "312",
            "accept-encoding": "gzip, br",
            "cdn-loop": "cloudflare; loops=1",
            "cf-connecting-ip": "91.108.5.76",
            "cf-ipcountry": "NL",
            "cf-ray": "98ea86c41db3f531-AMS",
            "cf-visitor": "{\"scheme\":\"https\"}",
            "cf-warp-tag-id": "301047e0-45cc-4792-9107-e54ecb369660",
            "connection": "keep-alive",
            "content-type": "application/json",
            "x-forwarded-for": "91.108.5.76",
            "x-forwarded-proto": "https"
          },
          "params": {},
          "query": {},
          "body": {
            "update_id": 383995441,
            "message": {
              "message_id": 312,
              "from": {
                "id": 7998792537,
                "is_bot": false,
                "first_name": "CleverCortex",
                "username": "CleverCortex",
                "language_code": "en"
              },
              "chat": {
                "id": 7998792537,
                "first_name": "CleverCortex",
                "username": "CleverCortex",
                "type": "private"
              },
              "date": 1760481080,
              "text": "Man punches his wife"
            }
          },
          "webhookUrl": "https://n8n.modernwizard.win/webhook/telegram-webhook",
          "executionMode": "production"
        }
      }
    ]
  },
  "connections": {
    "Telegram Webhook": {
      "main": [
        [
          {
            "node": "Has Message Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Message Content": {
      "main": [
        [
          {
            "node": "Is Voice Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Voice Message": {
      "main": [
        [
          {
            "node": "Get Voice File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normalize Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Voice File": {
      "main": [
        [
          {
            "node": "Fix Audio Format",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fix Audio Format": {
      "main": [
        [
          {
            "node": "Transcribe Voice (Groq)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transcribe Voice (Groq)": {
      "main": [
        [
          {
            "node": "Normalize Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Message": {
      "main": [
        [
          {
            "node": "Validate Content (Groq)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Content (Groq)": {
      "main": [
        [
          {
            "node": "Is Valid Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Valid Request": {
      "main": [
        [
          {
            "node": "Get Conversation Memory",
            "type": "main",
            "index": 0
          },
          {
            "node": "Legal Term Interpreter (Groq)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Legal Documents",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log Rejection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Rejection": {
      "main": [
        [
          {
            "node": "Send Rejection Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Rejection Response": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Conversation Memory": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "Prepare AI Context": {
      "main": [
        [
          {
            "node": "AI Legal Analysis (Groq)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Legal Analysis (Groq)": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Update Conversation Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Legal Response": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Query Embedding": {
      "main": [
        [
          {
            "node": "Debug Embedding Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search FindLaw Database": {
      "main": [
        [
          {
            "node": "Parse FindLaw HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Cornell Law": {
      "main": [
        [
          {
            "node": "Parse Cornell Law HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Google Scholar Legal": {
      "main": [
        [
          {
            "node": "Parse Google Scholar HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vector Search HTTP Request": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Debug Embedding Response": {
      "main": [
        [
          {
            "node": "Vector Search HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Conversation Memory": {
      "main": [
        [
          {
            "node": "Send Legal Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Legal Documents": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 6
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Prepare AI Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Legal Term Interpreter (Groq)": {
      "main": [
        [
          {
            "node": "Search CourtListener Database",
            "type": "main",
            "index": 0
          },
          {
            "node": "Search Google Scholar Legal",
            "type": "main",
            "index": 0
          },
          {
            "node": "Search Cornell Law",
            "type": "main",
            "index": 0
          },
          {
            "node": "Search FindLaw Database",
            "type": "main",
            "index": 0
          },
          {
            "node": "Generate Query Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Google Scholar HTML": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Parse Cornell Law HTML": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Parse FindLaw HTML": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Search CourtListener Database": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {},
  "versionId": "f54dbe9d-799c-488a-9f11-4b9857d6d67a",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "d410d616d2e66edd093f3b287f500ae19fea1907c2fd86cb81f4159b1117a048"
  },
  "id": "AdX8utsuSqpmu5Lj",
  "tags": []
}